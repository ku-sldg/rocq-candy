(* Local copy of structural tactics library from:  https://github.com/uwplse/StructTact 

We have locally modified this a great deal to add tactics that are useful for our proofs. *)
From Stdlib Require Import micromega.Lia Bool String List Ascii.
Import ListNotations.
From ExtLib Require Export Tactics BoolTac.
From Ltac2 Require Export Ltac2 Control Printf Std Array Lazy FMap Constr Ident Pstring.
Import Unsafe.

Ltac2 array_to_fmap (arr : ('k * 'v) array) : ('k, 'v) FMap.t :=
  Array.fold_left 
    (fun m (kv : 'k * 'v) => FMap.add (fst kv) (snd kv) m) 
    (FMap.empty FSet.Tags.string_tag) 
    arr.

(** [clean] removes any hypothesis of the shape [X = X]. *)
Ltac2 Notation "clean" :=
  repeat (match! goal with
    | [ h : ?_x = ?_x |- _ ] => 
      clear $h
  end).
Ltac2 Notation clean := clean.

(** [subst_max] performs as many [subst] as possible, clearing all
    trivial equalities from the context. *)
Ltac2 Notation "subst_max" :=
  repeat (clean);
  subst. (* The ltac2 subst calls subst_all (which I hope does truly all!) *)
Ltac2 Notation subst_max := subst_max.

(** The Coq [inversion] tries to preserve your context by only adding
    new equalities, and keeping the inverted hypothesis.  Often, you
    want the resulting equalities to be substituted everywhere.  [inv]
    performs this post-substitution.  Often, you don't need the
    original hypothesis anymore.  [invc] extends [inv] and removes the
    inverted hypothesis.  Sometimes, you also want to perform
    post-simplification.  [invcs] extends [invc] and tries to simplify
    what it can. *)


(** [inv] is a tactic that performs [inversion] on a hypothesis. *)
Ltac2 Notation "inv"
  arg(destruction_arg) 
  pat(opt(seq("as", intropattern)))
  ids(opt(seq("in", list1(ident)))) :=
  Std.inversion Std.FullInversion arg pat ids;
  subst_max.

Ltac2 Notation "invc"
  arg(destruction_arg) 
  pat(opt(seq("as", intropattern)))
  ids(opt(seq("in", list1(ident)))) :=
  Std.inversion Std.FullInversionClear arg pat ids;
  subst_max.

Ltac2 Notation "invcs"
  arg(destruction_arg) 
  pat(opt(seq("as", intropattern)))
  ids(opt(seq("in", list1(ident)))) :=
  Std.inversion Std.FullInversionClear arg pat ids;
  subst_max;
  simpl in *.

(* (** [inv_prop] finds the first hypothesis including the term [P] and uses [inv]
    to invert it. *)
Ltac2 inv_prop p :=
  match! goal with
  | [ h : context[$p] |- _] =>
    inv H
  end.

(** [inv_prop] finds the first hypothesis including the term [P] and uses [invc]
    to invert it. *)
Ltac invc_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    invc H
  end.

(** [inv_prop] finds the first hypothesis including the term [P] and uses
    [invcs] to invert it. *)
Ltac invcs_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    invcs H
  end. *)

(** [break_if] finds instances of [if _ then _ else _] in your goal or
    context, and destructs the discriminee, while retaining the
    information about the discriminee's value leading to the branch
    being taken. *)
Ltac break_if :=
  match goal with
    | [ |- context [ if ?x then _ else _ ] ] =>
      idtac "1";
      match type of x with
        | sumbool _ _ => idtac "3"; destruct x
        | _ => idtac "4"; destruct x eqn:?
      end
    | [ _h : context [ if ?x then _ else _ ] |- _] =>
      idtac "2";
      match type of x with
        | sumbool _ _ => idtac "5"; destruct x
        | _ => idtac "6"; destruct (x) eqn:?
      end
  end.

Ltac2 Notation "break_if" :=
  match! goal with
    | [ |- context [ if ?x then _ else _ ] ] =>
      printf "1";
      match! type x with
        | sumbool _ _ => printf "3"; destruct ($x)
        | _ => printf "4"; destruct ($x) eqn:?
      end
    | [ _h : context [ if ?x then _ else _ ] |- _] =>
      match! type x with
        | sumbool _ _ => destruct ($x)
        | _ => destruct ($x) eqn:?
      end
  end.
  
(* Ltac2 rec unpack_forall' (g : constr) (counter : int)
    : constr * (constr * ident) list :=
  match Constr.Unsafe.kind g with
  | Constr.Unsafe.Prod binder body =>
      (* We found a forall / product, recurse. *)
      let (g', acc') := unpack_forall' body '(counter + 1) in
      let n := Constr.Binder.name binder in



  | _ =>
      (* No more forall, return g *)
      g, []
  end. *)

Ltac2 rec unpack_forall (g : constr) : constr :=
  match Constr.Unsafe.kind g with
  | Constr.Unsafe.Prod _typ body =>
      (* We found a forall / product, recurse. *)
      unpack_forall body
  | _ =>
      (* No more forall, return g *)
      g
  end.

Ltac2 print_kind (k : Constr.Unsafe.kind) :=
  match k with
  | Constr.Unsafe.Rel i => 
      printf "Rel(%i)\n" i
  | Constr.Unsafe.Var id => 
      printf "Var(%s)\n" (Ident.to_string id)
  | Constr.Unsafe.Meta m => 
      printf "Meta\n"
  | Constr.Unsafe.Evar ev arr =>
      printf "Evar(, <array>)\n"
  | Constr.Unsafe.Sort s =>
      printf "Sort(_)\n"
  | Constr.Unsafe.Cast c _ _ =>
      printf "Cast(_)\n"
  | Constr.Unsafe.Prod b typ =>
      printf "Prod(binder: %s, _)\n" 
      (match Binder.name b with
      | Some id => Ident.to_string id
      | None => "None"
      end)
  | Constr.Unsafe.Lambda b typ =>
      printf "Lambda(binder: %s, _)\n" (match Binder.name b with | Some id => Ident.to_string id | None => "None" end)
  | Constr.Unsafe.LetIn b v t =>
      printf "LetIn(binder: %s, _, _)\n" (match Binder.name b with | Some id => Ident.to_string id | None => "None" end)
  | Constr.Unsafe.App f args =>
      printf "App(fun, args[%i])\n" (Array.length args)
  | Constr.Unsafe.Constant cst inst =>
      printf "Constant()\n" 
  | Constr.Unsafe.Ind ind inst =>
      printf "Inductive()\n"
  | Constr.Unsafe.Constructor ctor inst =>
      printf "Constructor()\n"
  | Constr.Unsafe.Case ci (c, _) how m arr =>
      printf "Case(_, _, _, _, %i branches)\n" (Array.length arr)
  | Constr.Unsafe.Fix idxs i bs defs =>
      printf "Fix(%i functions)\n" (Array.length defs)
  | Constr.Unsafe.CoFix i bs defs =>
      printf "CoFix(%i functions)\n" (Array.length defs)
  | Constr.Unsafe.Proj proj rel c =>
      printf "Proj(_)\n"
  | Constr.Unsafe.Uint63 u =>
      printf "Uint63()\n" 
  | Constr.Unsafe.Float f =>
      printf "Float(_)\n"
  | Constr.Unsafe.String s =>
      printf "String(%s)\n" (Pstring.to_string s)
  | Constr.Unsafe.Array inst arr dft arr_ty =>
      printf "Array(%i elements)\n" (Array.length arr)
  end.

Ltac2 rec meta_break_if (out_c : constr) : unit :=
  let rec f (c : constr) := 
    (
      printf "%t" c;
      first [
        (printf "match_side";
        try (match! c with
        | if ?x then _ else _ =>
          printf "top_match_succeeded";
          (* print_kind (kind x); *)
          (* printf "%t" (type x); *)
          (* match! type x with
            | sumbool _ _ => printf "3"; destruct ($x)
            | _ => printf "4"; destruct ($x) eqn:?
          end *)
          printf "%t" x;
          destruct ($x)
        end));
        (printf "iter_side"; iter meta_break_if c)
      ]
    )
  in f out_c.
  
Print Ltac2 unpack_forall.

Example test : forall (x y z : bool), if x then True else False.
let goal := Control.goal () in
iter meta_break_if goal.
intros x;
let goal := Control.goal () in
if Unsafe.occurn 54321523151 goal then
  printf "found 2\n"
else
  printf "not found 2\n".

printf "%t" goal.


let goal := Control.goal () in
let goal_val := unpack_forall goal in
match! goal_val with
| if ?x then _ else _ =>
  printf "%t" x
end.
destruct _UNBOUND_REL_2.
  intros x.
  break_if.
  - exact I.
  - exact I.
printf "Hello %t" g.
match! goal with
| [ |- context [ if @?x x1 then _ else _ ] ] => printf "test"
end.
  intros x.
  break_if.
  - exact I.
  - exact I.


ltac1:(break_if).
break_if.

Ltac break_if' :=
  match goal with
    | [ |- context [ if ?X then _ else _ ] ] =>
      match type of X with
        (*| sumbool _ _ => destruct X*)
        | _ => destruct X eqn:?
      end
    | [ H : context [ if ?X then _ else _ ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

(** [break_match_hyp] looks for a [match] construct in some
    hypothesis, and destructs the discriminee, while retaining the
    information about the discriminee's value leading to the branch
    being taken. *)
Ltac break_match_hyp :=
  match goal with
    | [ H : context [ match ?X with _ => _ end ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

(** [break_match_goal] looks for a [match] construct in your goal, and
    destructs the discriminee, while retaining the information about
    the discriminee's value leading to the branch being taken. *)
Ltac break_match_goal :=
  match goal with
    | [ |- context [ match ?X with _ => _ end ] ] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

(** [break_match] breaks a match, either in a hypothesis or in your
    goal. *)
Ltac break_match := break_match_goal || break_match_hyp.

Ltac break_match_hyp_rec H :=
  match goal with
  | [ H : context [ match ?X with _ => _ end ] |- _] =>
    match type of X with
    | sumbool _ _ => destruct X
    | _ => destruct X eqn:?; repeat break_match_hyp_rec
    end
  end.

(** [break_inner_match' t] tries to destruct the innermost [match] it
    find in [t]. *)
Ltac break_inner_match' t :=
 match t with
   | context[match ?X with _ => _ end] =>
     break_inner_match' X || destruct X eqn:?
   | _ => destruct t eqn:?
 end.

(** [break_inner_match_goal] tries to destruct the innermost [match] it
    find in your goal. *)
Ltac break_inner_match_goal :=
 match goal with
   | [ |- context[match ?X with _ => _ end] ] =>
     break_inner_match' X
 end.

(** [break_inner_match_hyp] tries to destruct the innermost [match] it
    find in a hypothesis. *)
Ltac break_inner_match_hyp :=
 match goal with
   | [ H : context[match ?X with _ => _ end] |- _ ] =>
     break_inner_match' X
 end.

(** [break_inner_match] tries to destruct the innermost [match] it
    find in your goal or a hypothesis. *)
Ltac break_inner_match := break_inner_match_goal || break_inner_match_hyp.

(** [break_exists] destructs an [exists] in your context. *)
Ltac break_exists :=
  repeat match goal with
           | [H : exists _, _ |- _ ] => destruct H
         end.

(** [break_exists_exists] destructs an [exists] in your context, and uses
    the witness found as witness for your current goal. *)
Ltac break_exists_exists :=
  repeat match goal with
           | H:exists _, _ |- _ =>
             let x := fresh "x" in
             destruct H as [x]; exists x
         end.

(** [break_and] destructs all conjunctions in context. *)
Ltac break_and :=
  repeat match goal with
           | [H : _ /\ _ |- _ ] => destruct H
         end.

(** [break_and_goal] splits a conjunctive goal into one goal per
    conjunct.  In simpler terms, it splits a goal of the shape [G1 /\
    ... /\ Gn] into [n] goals [G1], ..., [Gn]. *)
Ltac break_and_goal :=
  match goal with
  | [ |- _ /\ _ ] => split
  end.

(** [solve_by_inverison' tac] succeeds if it can solve your goal by
    inverting a hypothesis and then running [tac]. *)
Ltac solve_by_inversion' tac :=
  match goal with
    | [H : _ |- _] => solve [inv H; tac]
  end.

(** [solve_by_inverison] succeeds if it can solve your goal by
    inverting a hypothesis and then running [auto]. *)
Ltac solve_by_inversion := solve_by_inversion' auto.

(** TODO: document this. *)
Ltac apply_fun f H:=
  match type of H with
    | ?X = ?Y => assert (f X = f Y)
  end.

(** [conclude H tac] assumes [H] is of the form [A -> B] and
    specializes it into [B] if it successfully proves [A] using
    [tac]. *)
Ltac conclude H tac :=
  (let H' := fresh in
   match type of H with
     | ?P -> _ => assert P as H' by (tac)
   end; specialize (H H'); clear H').

(** [concludes] specializes all implication hypotheses if it can prove
    their premise using [auto]. *)
Ltac concludes :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H auto
  end.

(** [forward H] performs forward reasoning in hypothesis [H] of the
    shape [A -> B] by asserting [A] to be proven.  You can
    subsequently call [concludes] to specialize [H] to [B]. *)
Ltac forward H :=
  let H' := fresh in
   match type of H with
     | ?P -> _ => assert P as H'
   end.

(** [forwards] performs forward reasoning in all hypotheses. *)
Ltac forwards :=
  match goal with
    | [ H : ?P -> _ |- _ ] => forward H
  end.

(** [find_elim_prop] finds a hypothesis that includes [P] and eliminates it with
    the built-in [elim] tactic. *)
Ltac find_elim_prop P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    elim H
  end.

(** [find_elim_prop] finds a hypothesis that includes [P] and eliminates it with
    the built-in [eelim] tactic. *)
Ltac find_eelim_prop P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    eelim H
  end.

(** [find_contradiction] solves a goal if two equalities are
    incompatible. *)
Ltac find_contradiction :=
  match goal with
    | [ H : ?X = _, H' : ?X = _ |- _ ] => rewrite H in H'; solve_by_inversion
  end.

(** [find_rewrite] performs a [rewrite] with some hypothesis in some
    other hypothesis. *)
Ltac find_rewrite :=
  subst_max;
  match goal with
  | [ H : ?X _ _ _ _ = _, H' : ?X _ _ _ _ = _ |- _ ] => rewrite H in H'
  | [ H : ?X = _, H' : ?X = _ |- _ ] => rewrite H in H'
  | [ H : ?X = _, H' : context [ ?X ] |- _ ] => rewrite H in H'
  | [ H : ?X = _ |- context [ ?X ] ] => rewrite H
  end.

(** [find_rewrite_lem lem] rewrites with [lem] in some hypothesis. *)
Ltac find_rewrite_lem lem :=
  match goal with
    | [ H : _ |- _ ] =>
      rewrite lem in H; [idtac]
  end.

(** [find_rewrite_lem_by lem t] rewrites with [lem] in some
    hypothesis, discharging the generated obligations with [t]. *)
Ltac find_rewrite_lem_by lem t :=
  match goal with
    | [ H : _ |- _ ] =>
      rewrite lem in H by t
  end.

(** [find_erewrite_lem_by lem] erewrites with [lem] in some hypothesis
    if it can discharge the obligations with [eauto]. *)
Ltac find_erewrite_lem lem :=
  match goal with
  | [ H : _ |- _] => erewrite lem in H by eauto
  | |- _ => erewrite lem by eauto
  end.

(** [find_reverse_rewrite] performs a [rewrite <-] with some hypothesis in some
    other hypothesis. *)
Ltac find_reverse_rewrite :=
  match goal with
    | [ H : _ = ?X _ _ _ _, H' : ?X _ _ _ _ = _ |- _ ] => rewrite <- H in H'
    | [ H : _ = ?X, H' : context [ ?X ] |- _ ] => rewrite <- H in H'
    | [ H : _ = ?X |- context [ ?X ] ] => rewrite <- H
  end.

(** [find_inversion] find a symmetric equality and performs [invc] on it. *)
Ltac find_inversion :=
  match goal with
    | [ H : ?X _ _ _ _ _ _ = ?X _ _ _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ _ _ = ?X _ _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ _ = ?X _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ = ?X _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ = ?X _ _ |- _ ] => invc H
    | [ H : ?X _ = ?X _ |- _ ] => invc H
  end.

(** [prove_eq] derives equalities of arguments from an equality of
    constructed values. *)
Ltac prove_eq :=
  match goal with
    | [ H : ?X ?x1 ?x2 ?x3 = ?X ?y1 ?y2 ?y3 |- _ ] =>
      assert (x1 = y1) by congruence;
        assert (x2 = y2) by congruence;
        assert (x3 = y3) by congruence;
        clear H
    | [ H : ?X ?x1 ?x2 = ?X ?y1 ?y2 |- _ ] =>
      assert (x1 = y1) by congruence;
        assert (x2 = y2) by congruence;
        clear H
    | [ H : ?X ?x1 = ?X ?y1 |- _ ] =>
      assert (x1 = y1) by congruence;
        clear H
  end.

(** [tuple_inversion] inverses an equality of tuple into equalities for
    each component. *)
Ltac tuple_inversion :=
  match goal with
    | [ H : (_, _, _, _) = (_, _, _, _) |- _ ] => invc H
    | [ H : (_, _, _) = (_, _, _) |- _ ] => invc H
    | [ H : (_, _) = (_, _) |- _ ] => invc H
  end.

(** [f_apply H f] derives a hypothesis of type [f X = f Y] if [H] has
    type [X = Y]. *)
Ltac f_apply H f :=
  match type of H with
    | ?X = ?Y =>
      assert (f X = f Y) by (rewrite H; auto)
  end.

(** [break_let] breaks a destructuring [let] for a pair. *)
Ltac break_let :=
  match goal with
    | [ H : context [ (let (_,_) := ?X in _) ] |- _ ] => destruct X eqn:?
    | [ |- context [ (let (_,_) := ?X in _) ] ] => destruct X eqn:?
  end.

(** [break_or_hyp] breaks a disjunctive hypothesis, splitting your
    goal into two. *)
Ltac break_or_hyp :=
  match goal with
    | [ H : _ \/ _ |- _ ] => invc H
  end.

(** [copy_apply lem H] adds a hypothesis obtained by [apply]-ing [lem]
    in [H]. *)
Ltac copy_apply lem H :=
  let x := fresh in
  pose proof H as x;
    apply lem in x.

(** [copy_eapply lem H] adds a hypothesis obtained by [eapply]-ing
    [lem] in [H]. *)
Ltac copy_eapply lem H :=
  let x := fresh in
  pose proof H as x;
    eapply lem in x.

(** [conclude_using tac] specializes a hypothesis if it can prove its
    premise using [tac]. *)
Ltac conclude_using tac :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H tac
  end.

(** [find_higher_order_rewrite] tries to [rewrite] with
    possibly-quantified hypotheses into other hypotheses or the
    goal. *)
Ltac find_higher_order_rewrite :=
  match goal with
    | [ H : _ = _ |- _ ] => rewrite H in *
    | [ H : forall _, _ = _ |- _ ] => rewrite H in *
    | [ H : forall _ _, _ = _ |- _ ] => rewrite H in *
  end.

(** [find_reverse_higher_order_rewrite] tries to [rewrite <-] with
    possibly-quantified hypotheses into other hypotheses or the
    goal. *)
Ltac find_reverse_higher_order_rewrite :=
  match goal with
    | [ H : _ = _ |- _ ] => rewrite <- H in *
    | [ H : forall _, _ = _ |- _ ] => rewrite <- H in *
    | [ H : forall _ _, _ = _ |- _ ] => rewrite <- H in *
  end.

(** [find_apply_hyp_goal] tries solving the goal applying some
    hypothesis. *)
Ltac find_apply_hyp_goal :=
  match goal with
    | [ H : _ |- _ ] => solve [apply H]
  end.

(** [find_copy_apply_lem_hyp lem] tries to find a hypothesis to which
    [lem] can be applied, and adds a hypothesis resulting from the
    application. *)
Ltac find_copy_apply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => copy_apply lem H
  end.

(** [find_apply_hyp_hyp] finds a hypothesis which can be applied in
    another hypothesis, and performs the application. *)
Ltac find_apply_hyp_hyp :=
  match goal with
    | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
      apply H in H'; [idtac]
    | [ H : _ -> _ , H' : _ |- _ ] =>
      apply H in H'; auto; [idtac]
  end.

Ltac find_eapply_hyp_hyp :=
  match goal with
  | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
    eapply H in H'; [idtac]
  | [ H : _ -> _ , H' : _ |- _ ] =>
    eapply H in H'; auto; [idtac]
  end.

(** [find_copy_apply_hyp_hyp] finds a hypothesis which can be applied
    in another hypothesis, and adds a hypothesis with the application
    performed. *)
Ltac find_copy_apply_hyp_hyp :=
  match goal with
    | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
      copy_apply H H'; [idtac]
    | [ H : _ -> _ , H' : _ |- _ ] =>
      copy_apply H H'; auto; [idtac]
  end.

(** [find_apply_lem_hyp lem] finds a hypothesis where [lem] can be
    [apply]-ed, and performes the application. *)
Ltac find_apply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => apply lem in H
  end.

(** [find_eapply_lem_hyp lem] finds a hypothesis where [lem] can be
    [eapply]-ed, and performes the application. *)
Ltac find_eapply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => eapply lem in H
  end.

(** TODO: document this. *)
Ltac insterU H :=
  match type of H with
    | forall _ : ?T, _ =>
      let x := fresh "x" in
      evar (x : T);
      let x' := (eval unfold x in x) in
        clear x; specialize (H x')
  end.

(** TODO: document this. *)
Ltac find_insterU :=
  match goal with
    | [ H : forall _, _ |- _ ] => insterU H
  end.

(** [eapply_prop P] finds a hypothesis proving [P] and [eapply]-es it. *)
Ltac eapply_prop P :=
  match goal with
    | H : P _ |- _ =>
      eapply H
  end.

(** [find_eapply_prop P] finds a hypothesis including [P] and [eapply]-es it. *)
Ltac find_eapply_prop P :=
  match goal with
    | H : context [ P ] |- _ =>
      eapply H
  end.

(** [isVar t] succeeds if term [t] is a variable in the context. *)
Ltac isVar t :=
    match goal with
      | v : _ |- _ =>
        match t with
          | v => idtac
        end
    end.

(** [remGen t] is useful when one wants to do induction on a
    hypothesis whose indices are not concrete.  By default, the
    [induction] tactic will first generalize them, losing information
    in the process.  By introducing an equality, one can save this
    information while generalizing the hypothesis. *)
Ltac remGen t :=
  let x := fresh in
  let H := fresh in
  remember t as x eqn:H;
    generalize dependent H.

(** [remGenIfNotVar t] performs [remGen t] unless [t] is a simple
    variable. *)
Ltac remGenIfNotVar t := first [isVar t| remGen t].

(** [rememberNonVars H] will pose an equation for all indices of [H]
    that are concrete.  For instance, given: [H : P a (S b) c], it
    will generalize into [H : P a b' c] and [EQb : b' = S b]. *)
Ltac rememberNonVars H :=
  match type of H with
    | _ ?a ?b ?c ?d ?e =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c;
      remGenIfNotVar d;
      remGenIfNotVar e
    | _ ?a ?b ?c ?d =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c;
      remGenIfNotVar d
    | _ ?a ?b ?c =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c
    | _ ?a ?b =>
      remGenIfNotVar a;
      remGenIfNotVar b
    | _ ?a =>
      remGenIfNotVar a
  end.

(* [generalizeEverythingElse H] tries to generalize everything that is
   not [H]. *)
Ltac generalizeEverythingElse H :=
  repeat match goal with
           | [ x : ?T |- _ ] =>
             first [
                 match H with
                   | x => fail 2
                 end |
                 match type of H with
                   | context [x] => fail 2
                 end |
                 revert x]
         end.

(* [prep_induction H] prepares your goal to perform [induction] on [H] by:
   - remembering all concrete indices of [H] via equations;
   - generalizing all variables that are not depending on [H] to strengthen the
     induction hypothesis. *)
Ltac prep_induction H :=
  rememberNonVars H;
  generalizeEverythingElse H.

(* [econcludes] tries to specialize a hypothesis using [eauto]. *)
Ltac econcludes :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H eauto
  end.

(** [find_copy_eapply_lem_hyp lem] tries to find a hypothesis to which
    [lem] can be [eapply]-ed, and adds a hypothesis resulting from the
    application. *)
Ltac find_copy_eapply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => copy_eapply lem H
  end.

(** [apply_prop_hyp P Q] tries to [apply] a hypothesis about [P] to a
    hypothesis about [Q]. *)
Ltac apply_prop_hyp P Q :=
  match goal with
  | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
    apply H in H'
  end.

(** [apply_prop_hyp P Q] tries to [eapply] a hypothesis about [P] to a
    hypothesis about [Q]. *)
Ltac eapply_prop_hyp P Q :=
  match goal with
  | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
    eapply H in H'
  end.

(** [apply_prop_hyp P Q] tries to [eapply] a hypothesis about [P] to a
    hypothesis about [Q], posing the result as a new hypothesis. *)
Ltac copy_eapply_prop_hyp P Q :=
  match goal with
    | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
      copy_eapply H H'
  end.

Ltac eapply_lem_prop_hyp lem P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    eapply lem in H
  end.

Ltac copy_eapply_lem_prop_hyp lem P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    copy_eapply lem H
  end.

(** [find_false] finds a hypothesis of the shape [P -> False] in the
    context and cuts your goal with it, leaving you with the
    obligation of proving its premise [P]. *)
Ltac find_false :=
  match goal with
    | H : _ -> False |- _ => exfalso; apply H
  end.

(** [injc H] performs [injection] on [H], then clears [H] and
    simplifies the context. *)
Ltac injc H :=
  injection H; clear H; intros; subst_max.

(** [find_injection] looks for an [injection] in the context and
    performs [injc]. *)
Ltac find_injection :=
  match goal with
    | [ H : ?X _ _ _ _ _ _ _ = ?X _ _ _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ _ _ = ?X _ _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ _ = ?X _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ = ?X _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ = ?X _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ = ?X _ _ |- _ ] => injc H
    | [ H : ?X _ = ?X _ |- _ ] => injc H
  end.

(** [aggressive_rewrite_goal] rewrites in the goal with any
    hypothesis. *)
Ltac aggressive_rewrite_goal :=
  match goal with H : _ |- _ => rewrite H end.

(** [break_exists_name x] destructs an existential in context and
    names the witness [x]. *)
Ltac break_exists_name x :=
  match goal with
  | [ H : exists _, _ |- _ ] => destruct H as [x H]
  end.

Tactic Notation "check_num_goals" natural(n) :=
  let num := numgoals in
  guard num = n.

Tactic Notation "check_num_goals_le" natural(n) :=
  let num := numgoals in
  guard num <= n.

Ltac break_logic_hyps :=
  repeat (
    try break_or_hyp;
    try break_and;
    try break_exists
  ).

Ltac break_iff :=
  match goal with
  | |- _ <-> _ => split; intros
  end.

Ltac full_do_bool :=
  intros; break_logic_hyps;
  do_bool;
  (* Do bool from extlib does well on hyps, but not goals *)
  repeat 
    (match goal with
    | |- context [andb ?x ?y = true] => 
      erewrite andb_true_iff; split; do_bool
    | |- context [andb ?x ?y = false] => 
      erewrite andb_false_iff; split; do_bool
    | |- context [orb ?x ?y = true] => 
      erewrite orb_true_iff; do_bool; eauto
    | |- context [orb ?x ?y = false] => 
      erewrite orb_false_iff; do_bool; eauto
    end; try simple congruence 1);
  try simple congruence 1.

Ltac max_RW :=
  simpl in *;
  subst_max;
  repeat find_rewrite.

Ltac breaker :=
  repeat (break_match; subst; try congruence).

Ltac rw_all :=
  subst_max;
  repeat (
    match goal with
    | H : context [iff _ _] , H' : _ |- _ => 
      erewrite H in H'
    | H : context [eq _ _] , H' : _ |- _ => 
      erewrite H in H'
    | H : context [iff _ _] |- _ => 
      erewrite H
    | H : context [eq _ _] |- _ =>
      erewrite H
    end;
    subst_max;
    eauto;
    try simple congruence 1
  ); eauto.

(* Simplification hammer.  Used at beginning of many proofs in this 
   development.  Conservative simplification, break matches, 
   invert on resulting goals *)
Ltac ff :=
  repeat (
    try unfold not in *;
    intros;
    (* Break up logical statements *)
    repeat break_and;
    repeat break_exists;
    try break_iff;
    (* 
    This is proving too computationly expensive to do in general

    (* We only break up goal ANDs f we <= the total number of goals *)
    try (
      let num := numgoals in
      break_and_goal; ff; 
      let num2 := numgoals in
      guard num2 <= num);
    *)
    (* We only break up hyp ORs if we <= the total number of goals *)
    try (
      let num := numgoals in
      break_or_hyp; ff; 
      let num2 := numgoals in
      guard num2 <= num);
    repeat (
      simpl in *;
      repeat find_rewrite;
      try break_match;
      try congruence;
      repeat find_rewrite;
      try congruence;
      repeat find_injection;
      try congruence;
      simpl in *;
      subst_max; eauto;
      try congruence
      (* Too expensive in general
      ; try solve_by_inversion *)
    )
  ).

(* Base tactic that all others use *)
Ltac ffc custom :=
  repeat (
    ff;
    custom;
    ff
  ).

Print String.
Print string.
From Ltac2 Require Import Ltac2 Printf Pstring Control.

Print string.
Print char.
Print pstring.
(* Individual flag tactics *)
Ltac ff_flag_lia := try lia.
Ltac ff_flag_unfold := repeat autounfold in *.
Ltac ff_flag_apply := repeat find_apply_hyp_hyp.
Ltac ff_flag_rw := rw_all.

(* Dispatcher for a single flag string *)
Local Open Scope string_scope.

Print pstring.

Ltac2 substring (start : int) (len : int) (str : string) :=
  let s := String.sub str start len in
  s.

Local Open Scope char_scope.

Ltac2 Type tactic_table :=  (string, unit -> unit) FMap.t.

Ltac2 tac_table : unit -> tactic_table :=
  fun _ => array_to_fmap 
  [| ("l", fun _ => try ltac1:(lia));
     ("u", fun _ => ltac1:(repeat autounfold in *));
     ("a", fun _ =>  repeat find_apply_hyp_hyp; ltac1:(idtac "l"));
     ("o", fun _ => ltac1:(idtac "o"));
     ("hh", fun _ => ltac1:(idtac "hh"))
  |].

Ltac2 interp_tac_char (str : string) (tab : tactic_table) : unit :=
  match FMap.find_opt str tab with
  | Some f => f ()
  | None => Control.throw (Tactic_failure (Some (Message.concat (Message.of_string "Unknown tactic:") (Message.of_string str))))
  end.

Ltac2 rec interp_tac_str' (str : string) (tab : tactic_table) : unit :=
  match str with
  | "" => ()
  | _ =>
    printf "interp_tac_str' %s\n" str;
    let h := String.sub str 0 1 in
    let t := String.sub str 1 (Int.sub (String.length str) 1) in
    interp_tac_char h tab;
    interp_tac_str' t tab
  end.

Ltac2 interp_tac_str (str : string) : unit :=
  let table := tac_table () in
  printf "interp_tac_str %s\n" str;
  interp_tac_str' str table.

Import Ascii.
Example test : True.
interp_tac_str "hello".
let s1 := interp_char "h" in
let s2 := interp_char "e" in
(* let s3 := interp_char s1 in *)
(* let str := String.app s1 s2 in *)
s1; s2.
printf "%s" str.
printf "%s" (interp_char (interp_char "h")).

(* Test function for the above *)

Ltac2 test (s : string) :=
  match s with
  | char :: _ => Control.throw Not_found
  | "h" => Control.throw No_value
  | "e" => Control.throw Match_failure
  | "l" => Control.throw Not_found
  | "o" => Control.throw Not_focussed
  | _ => Control.throw Assertion_failure
  end.

Example test : True.
test " ".

Ltac2 coq_string_to_ltac_string constr:(string) :=
  let s := String.to_list constr in
  let rec loop s acc :=
    match s with
    | [] => acc
    | c :: s' => loop s' (acc ++ [c])
    end
  in
  loop s [].

(* Printf format string *)

Print Ltac2 substring.

Ltac2 ff_dispatch_flag flag :=
  lazy_match! flag with
  | "l" => ltac1:(ff_flag_lia)
  | "u" => ltac1:(ff_flag_unfold)
  | "a" => ltac1:(ff_flag_apply)
  | "r" => ltac1:(ff_flag_rw)
  | _ => Control.zero (Tactic_failure (Some (Message.concat (Message.of_string "Unknown flag for 'ffc':") (Message.of_string flag))))
  end.

(* Main driver: applies ff; <custom>; ff repeatedly *)
Ltac flag_caller flags :=
  lazymatch flags with
  | (?flag :: ?rest) =>
      ff_dispatch_flag flag;
      flag_caller rest
  | nil => idtac
  end.

Example test : True.
printf "%s" (substring 0 1 "hello").

(* Find the index of a character in a string *)
Ltac print_chars_on_new_line str :=
  let s := eval cbv in str in
  let rec loop s :=
    lazymatch s with
    | "" => idtac
    | _ =>
      let head := substring 0 (index " " s) s in
      let tail := substring (1 + index " " s) (String.length s - 1 - index " " s) s in
      idtac head;
      loop tail
    end
  in
  match s with
  | "" => idtac
  | _ =>
    lazymatch index " " s with
    | 0 => idtac(s)
    | _ =>
      loop s
    end
  end.

(* Split a string by space into a list of strings *)
Ltac ffc_parse_flags str :=
  let s := eval cbv in str in
  let rec loop s acc :=
    lazymatch s with
    | "" => acc
    | _ =>
      let head := substring 0 (index " " s) s in
      let tail := substring (1 + index " " s) (String.length s - 1 - index " " s) s in
      loop tail (acc ++ [head])
    end
  in
  match s with
  | "" => constr:(@nil string)
  | _ =>
    lazymatch index " " s with
    | 0 => constr:([s])
    | _ =>
      let flags := loop s (@nil string) in
      flags
    end
  end.

Ltac ff_core flags :=
  repeat (
    ff;
    flag_caller flags;
    ff
  ).

(* Convenience notation: ffc with flags *)
Tactic Notation "ff" "with" constr_list(flags) :=
  let parsed := eval cbv in flags in
  ff_core parsed.

Ltac ffu := ff with ["u"].
Ltac ffl := ff with ["l"].
Ltac ffa := ff with ["a"].
Ltac ffr := ff with ["r"].

(* Ltac ffl :=
  repeat (ff;
    try lia;
  ff).

Ltac ffu :=
  repeat (ff;
    repeat autounfold in *;
  ff).

Ltac ffa :=
  repeat (ff;
    repeat find_apply_hyp_hyp;
    ff).

Ltac ffr :=
  repeat (ff;
    rw_all;
    ff).

Tactic Notation "ffc" "using" tactic2(tac) :=
  repeat (ff;
    tac;
    ff). 

Tactic Notation "ffa" "using" tactic2(tac) :=
  repeat (ff;
    repeat find_apply_hyp_hyp;
    tac;
    ff). *)

Ltac target_find_rewrite H :=
  lazymatch type of H with
  | ?X = ?Y =>
    (* rewrite in goals *)
    lazymatch goal with
    | [ |- context[X] ] => rewrite H
    end;
    (* rewrite in hyps *)
    lazymatch goal with
    | [ H' : context[X] |- _ ] => 
      rewrite H in H'; clear H
    end
  end.

Ltac clean_up_hyp H :=
  (* try injc H;
  try target_find_rewrite H; *)
  try simple congruence 1.

Ltac target_break_match H :=
  lazymatch type of H with
  | context[match ?X with _ => _ end] => 
    let Hbm := fresh "Hbm" in
    destruct X eqn:Hbm; 
    try find_injection;
    try simple congruence 1; try target_break_match Hbm;
    try target_break_match H
  end.
